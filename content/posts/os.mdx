---
title: "Open Source"
excerpt: "Exploring the world of open source software and its impact on modern development"
date: "2025-03-07T12:00:00Z"
author: "Alvaro Peña"
image: "/blog/open-source.jpg"
category: "Technology"
slug: "os"
---

Open Source is the only future for software. Propietary software will fall.

We believe an EdTech company cannot be build with propietary software. If users cannot be aware of what information companies are extracting from them or how are they teaching them then there's no point.

Today we are explaining in the following blog post how our algorithm works in detail so everyone, even a non-technical person can understand how do we help people learn.

Chop is a multi-language learning system.

Multi-language because we allow people from all language speaken countries to be able to learn in our platform, regardless of what language do they speak.

Since our launch we have expanded from English-only to Spanish, Italian, German, Japanese, and more languages.

The language context layer we implement goes like this:

User → Communities (Topics) → Languages → Cards

The experience from users vary depending on wether they are a free or premium user.

Learning in Chop is and will always be free. However, as much as we would like to provide the best experience for free to everyone no business is sustainable that way, that's why we allow limited-learning for non-paying users.

When you create an account in Chop, you are asked to join one community, at the beginning we allowed only Italian as our community because that's what we launched with.

Once you select that community, our backend will fetch pre-generated cards from all difficulty levels.

For example, if you choose Italian as the first community for you to learn, we will fetch 28 cards (3 batches) with multiple levels of difficulty which will allow us to determine your level of expertise. Depending on how many cards you get right, let's say we show you one card that's right, and you get them right, we will show you a harder card and so forth until we reach 28 cards, same goes for if you make mistakes we will show you easier cards.

Once you reach your 28 cards of the day (your study session) you will need to wait 24 hours to complete your next session of study.

During those 24 hours our agents will determine based on the cards you answered and all the metrics we track from our users the best cards to be shown the next day (after thoes 24 hours have gone by). Same logic, we will show cards depending on if you get them all right and if you get them all wrong as well as with variations witthin those cards.

As a free user also you won't be able to join more than two communities, and this will only be unlocked once you complete your first session of study, each session of study consists of 28 cards so if you join two communities we will show 28 cards again but they will be merged from the new community you've joined as well.

The reasoning behind this is that we are inspired by TikTok so we track study sessions independently, we will make sure you learn.

Another scenario where you will have to wait is after 24 hours is if you spent all your lives, so if you make more than 20 mistakes, which is what you are granted for creating an account you will have to wait 24 hours for 10 lives to be respawened and after that we will only refill 10 lives, they are not cumulative.

Free Users (28 cards/day):
Initial load: Show cached cards instantly based on their level
Track performance during those 28 cards
Use 24-hour waiting period to:
Analyze their performance
Pre-generate next day's cards at appropriate difficulties
Have them ready before they return

## Premium

Now in the case of premium users, if you complete your first session of study adn decide that you don't want to wait and purchase a subscription, you have to options, pay for the monthly plan or pay for the yearly plan, of course, we recommend the yearly plan  because it's much cheaper.

In the premium subscription you will earn inifinte lives (you can make as many mistakes as you want and you can join as many communities as you want, once you complete the cards of each session of each ommunity you are part of you will conitnue seeing more cards but they will be for future topics)

Here are some of the concepts we have implemented in our backend to be able to give you as much of a smooth experience as possible.

We use background generation, streaming and agents.

We have card templates and user cards.

We generate cards and link them to users. Meaning that you as a user can link himself to 1-many relationshi pto cards.

Premium users enjoy a TikTok-like Experience:
Instant initial load: 
Seamless scrolling
Content ready before user reaches it
Personalized difficulty progression

With the card generation strategies we debated between two approaches: a pure real-time generation, meaning that every time a user is using the app we are generating cards on the fly, unfortunately this will take too much and leave the user waiting for cards.

# Pros:
# - Perfect difficulty progression
# - Always fresh content
# Cons:
# - Slow (7-10 seconds wait)
# - High API costs
# - Not scalable

At the same time thee pure cache approach: ensures an instant loading of cards as well as low cost because we will be caching already generated cards, however them being static would make it hard to personalize them.
# Pros:
# - Instant loading
# - Low cost
# Cons:
# - No personalization
# - Static difficulty
# - Like showing same TikToks to everyone


That's the reason why we decided to go for a hybrid approach, which we call a card bucket system.

Our system should comply with the following:
- We want instant card delivery like TikTok
- Cards should progress in difficulty based on user performance
- Current system is slow because we generate cards on demand
- Users have to wait too long

In our solution, in the carrd bucket system we have 5 buckets, one for each level of diffculty (1 being the easiest and 5 the hardest). Each bucket contains pre-generated cards for that difficulty, this is Like TikTok having videos ready before users need them.

When user opens app, we instantly give cards from appropriate bucket. No waiting because cards are already generated, like TikTok showing you videos instantly.

We arrange a difficulty progression: Monitor how well user answers cards. If they do well, take next cards from a harder bucket. If they struggle, take next cards from an easier bucket, like TikTok learning your preferences.

Monitor how many cards are left in each bucket. When a bucket gets low, generate more cards in background, Users never notice this happening, Like TikTok preparing more content while you watch.

Finally, we implement a user history tracking, meaning we keep track of which cards each user has seen. Never show same card twice to same user, still maintain personal progress/stats, Like TikTok remembering what you've watched

Initial load: Same as free users, start with cached cards
As they approach card 20-25 of their current batch:
Start background generation of next batch
Use their performance from current batch to determine difficulty
Have next batch ready before they need it

Progressive Difficulty System:
Maintain difficulty levels (1-5) with sub-levels (1.1, 1.2, 1.3, etc.)
Track "mastery score" per topic/concept
Example progression:

   Card 1 (Level 1.0) ✓ correct
   Card 2 (Level 1.1) ✓ correct
   Card 3 (Level 1.2) ✗ wrong
   Card 4 (Level 1.1) ✓ correct

Infrastructure for Unlimited Learning:
Multi-Layer Cache:
Hot cache: Most common difficulty levels, instant access
Warm cache: Adjacent difficulty levels, very quick access
Cold generation: New cards for unexplored difficulties
Predictive Generation:
While user is on card 1, prepare cards 8-15
While on cards 8-15, prepare 16-23
Always stay ahead of user's progress
Smart Batching:

   Current batch (showing): 1-7
   Next batch (ready): 8-14
   Generating batch: 15-21
   Planning batch: 22-28

Performance-Based Pipeline:

   User answers card 5 correctly
   ↓
   System checks performance trend
   ↓
   Adjusts difficulty of generating batch
   ↓
   New cards ready before user reaches them

them
Emergency Fallbacks:
If user is exceptionally fast
If generation is slower than expected
If API has issues

   Priority 1: Show cached cards at exact difficulty
   Priority 2: Show cached cards at ±1 difficulty
   Priority 3: Show previously generated cards user hasn't seen
   Priority 4: Quick-generate simple cards

cards
This creates a "never-ending" learning experience where:
Users never wait
Difficulty constantly adjusts
System stays ahead of user progress
Always has fallback options
Premium users can continue indefinitely
The key is to make the system:
Predictive - Always preparing future cards
Adaptive - Adjusting difficulty based on real-time performance
Resilient - Having multiple fallback options
Seamless - Users never experience waiting or gaps
Think of it like Netflix's buffering system - while you're watching one part, it's loading the next part, but also adjusting quality based on your connection, always ensuring uninterrupted viewing.

Smart Filtering:
Before showing any card to user:
Check against their history
Only show cards they haven't seen
Exception: Cards they performed poorly on (intentional repetition)

Instead of sending all previous cards as context, we can:
Send last 10-20 questions as immediate context
Send patterns/themes they've seen recently
Send concepts they've mastered
Send concepts they're struggling with

Concept Mapping:
Tag cards with concepts they cover
     Card A: "What's 'hello'?" 
     Tags: [greetings, basics, common_words]
     
     Card B: "Translate 'good morning'"
     Tags: [greetings, time_expressions, common_words]
     Use these tags to track concept coverage
Ensure varied concept exposure

Use these tags to track concept coverage
Ensure varied concept exposure
Intelligent Repetition:
Some repetition is good for learning
System decides to repeat based on:
Time since last seen
Previous performance
Concept importance
Current difficulty level
Card Generation Strategy:
Instead of checking against ALL previous cards
Check against:
Recently generated cards (last 100)
Common patterns
Core concepts
Use semantic similarity to detect similar questions

Difficulty Progression:
   User Journey Example:
   → Basic greetings (mastered)
   → Time expressions (struggling)
   → Numbers (not started)
   
   System will:
   - Move away from greetings
   - Reinforce time expressions
   - Introduce numbers gradually

   Content Buckets:
   Hot Bucket: Ready to show
   Warm Bucket: Generated, needs verification
   Cold Bucket: Being generated
   Archive: Previously shown cards

   Generation Rules:
Never generate exact duplicates
Allow concept repetition with different approaches
Vary question types (multiple choice/text input)
Adapt to user's learning style
    If user is strong in greetings:
      → Generate harder greeting cards
      → Introduce new related concepts
      → Mix with other topics

      This creates a system where:
Cards feel fresh and unique
Learning is personalized
Repetition is intentional, not accidental
Content is always available
Generation stays ahead of user
Premium users get continuous, quality content
Think of it like Spotify's Discover Weekly:
Knows what you've heard
Knows what you like
Provides fresh content
Sometimes reintroduces old favorites
Always has more ready
But never feels repetitive
The key is balancing:
Content freshness
Learning effectiveness
Generation efficiency
User engagement